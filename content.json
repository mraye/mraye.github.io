[{"title":"mybatis中association和collection的column传入多个参数值","date":"2018-05-30T15:43:58.000Z","path":"2018/05/30-mybatis-column-pro.html","text":"mybatis中association和collection的column传入多个参数值项目中在使用association和collection实现一对一和一对多关系时需要对关系中结果集进行筛选，如果使用懒加载模式，即联合使用select标签时，主sql和关系映射里的sql是分开的，查询参数传递成为问题。 mybatis文档: property description column 数据库的列名或者列标签别名。与传递给resultSet.getString(columnName)的参数名称相同。注意： 在处理组合键时，您可以使用column=“{prop1=col1,prop2=col2}”这样的语法，设置多个列名传入到嵌套查询语句。这就会把prop1和prop2设置到目标嵌套选择语句的参数对象中。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;resultMap id=\"findCountryCityAddressMap\" type=\"map\"&gt; &lt;result property=\"country\" column=\"country\"/&gt; &lt;collection property=\"cityList\" column=\"&#123;cityId=city_id,adr=addressCol, dis=districtCol&#125;\" //adr作为第二个sql查询条件key,即prop1属性 ofType=\"map\" //addressCol即为虚拟列名 javaType=\"java.util.List\" select=\"selectAddressByCityId\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"selectAddressByCityIdMap\" type=\"map\"&gt; &lt;result property=\"city\" column=\"city\"/&gt; &lt;collection property=\"addressList\" column=\"city\" ofType=\"map\" javaType=\"java.util.List\"&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;result property=\"district\" column=\"district\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findCountryCityAddress\" resultMap=\"findCountryCityAddressMap\"&gt; SELECT ct.country, ci.city_id, IFNULL(#&#123;addressQuery&#125;,'') addressCol, //为传入查询条件,构造虚拟列，虚拟列为查询条件参数值 IFNULL(#&#123;districtQuery&#125;,'') districtCol FROM country ct LEFT JOIN city ci ON ct.country_id = ci.country_id ORDER BY ct.country_id&lt;/select&gt;&lt;select id=\"selectAddressByCityId\" parameterType=\"java.util.Map\" resultMap=\"selectAddressByCityIdMap\"&gt; SELECT ci.city, ads.address, ads.district FROM ( SELECT city, city_id FROM city ci WHERE ci.city_id = #&#123;cityId&#125; ) ci LEFT JOIN address ads ON ads.city_id = ci.city_id &lt;where&gt; &lt;if test=\"adr!=null and adr!=''\"&gt; and ads.address RegExp #&#123;adr&#125; &lt;/if&gt; &lt;if test=\"dis!=null and dis!=''\"&gt; ads.district Regexp #&#123;dis&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试文件: 123456789@Testpublic void findCountryCityAddressTest() throws JsonProcessingException &#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(\"addressQuery\",\"1168\"); List&lt;Map&lt;String, Object&gt;&gt; rs = countryManager.findCountryCityAddress(param); ObjectMapper mapper = new ObjectMapper(); ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter(); System.out.println(writer.writeValueAsString(rs));&#125; 测试结果: 1234567891011121314151617181920[ &#123; \"country\": \"Afghanistan\", \"cityList\": [&#123; \"city\": \"Kabul\", \"addressList\": [&#123; \"address\": \"1168 Najafabad Parkway\", \"district\": \"Kabol\" &#125; ] &#125; ], \"city_id\": 251 &#125;, &#123; \"country\": \"Algeria\", \"cityList\": [], \"city_id\": 59 &#125;] 可以看到，确实将查询条件通过column参数传入到第二个sql中，并执行成功","tags":[{"name":"association","slug":"association","permalink":"https://mraye.github.io/tags/association/"},{"name":"collection","slug":"collection","permalink":"https://mraye.github.io/tags/collection/"}]},{"title":"行列转换(二)","date":"2018-05-28T14:03:36.000Z","path":"2018/05/28-row-to-column-secd.html","text":"情景一1.有限列类型: 12345678910111213141516171819+----+----------+-------+--------+| id | fruit_id | color | weight |+----+----------+-------+--------+| 1 | 1 | 红 | 23 || 2 | 1 | 黑 | 54 || 3 | 2 | 红 | 12 || 4 | 2 | 黑 | 43 || 5 | 3 | 黑 | 90 |+----+----------+-------+--------+ | V +----------+----+----+ | fruit_id | 红 | 黑 | +----------+----+----+ | 1 | 23 | 54 | | 2 | 12 | 43 | | 3 | 0 | 90 | +----------+----+----+ sql实现: 1234567SELECT fruit_id, max(case WHEN color='红' THEN weight ELSE 0 END) '红', max(CASE WHEN color='黑' THEN weight ELSE 0 END) '黑'FROMt_fruitGROUP BY fruit_id 2.无限列类型，使用动态sql(或者存储过程): 123456789101112131415161718192021222324252627set @sql='';SELECT @sql:= concat( @sql, 'sum(case color when \\'',color, '\\' then weight else 0 end) as \\'', color, '\\',' )FROM(SELECT DISTINCT colorFROM t_fruit)temp;set @sql=concat( 'SELECT fruit_id,', LEFT(@sql, CHAR_LENGTH(@sql)-1), -- LEFT(@sql, LENGTH(@sql)-1), 如果含有中文字符就不行... ' from t_fruit group by fruit_id');-- SELECT @sql;PREPARE stmt FROM @sql;EXECUTE stmt; script 12345678910111213141516CREATE TABLE `t_fruit` ( `id` int(11) NOT NULL AUTO_INCREMENT, `fruit_id` int(11) DEFAULT NULL, `color` varchar(255) DEFAULT NULL, `weight` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;//插入INSERT INTO `dbl`.`t_fruit` (`id`, `fruit_id`, `color`, `weight`) VALUES('1', '1', '红', '23'),('2', '1', '黑', '54'),('3', '2', '红', '12'),('4', '2', '黑', '43'),('5', '3', '黑', '90'); 情景二列转行: 12345678910111213141516171819+----+----------+-------------+-----------+| id | fruit_id | color_black | color_red |+----+----------+-------------+-----------+| 1 | 1 | 54 | 23 || 2 | 2 | 43 | 12 || 3 | 3 | 90 | 0 |+----+----------+-------------+-----------+ | V +----------+-------+-----------+ | fruit_id | color | weight | +----------+-------+-----------+ | 1 | 红 | 23 | | 1 | 黑 | 54 | | 2 | 红 | 12 | | 2 | 黑 | 43 | | 3 | 红 | 0 | | 3 | 黑 | 90 | +----------+-------+-----------+ sql实现: 12345678910111213141516SELECT fruit_id, '红' color, color_red weightFROM t_color_fruitUNION ALL SELECT fruit_id, '黑' color, color_black weight FROM t_color_fruitORDER BY fruit_id, color script 123456789101112131415CREATE TABLE `t_color_fruit` ( `id` int(11) NOT NULL AUTO_INCREMENT, `fruit_id` int(11) DEFAULT NULL, `color_black` varchar(255) DEFAULT NULL, `color_red` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;//插入INSERT INTO `dbl`.`t_color_fruit` (`id`, `fruit_id`, `color_black`, `color_red`)VALUES('1', '1', '54', '23'),('2', '2', '43', '12'),('3', '3', '90', '0');","tags":[{"name":"sql","slug":"sql","permalink":"https://mraye.github.io/tags/sql/"}]},{"title":"git忽略提交文件","date":"2018-05-27T03:29:28.000Z","path":"2018/05/27-git-ignore-file.html","text":"git忽略不想加入版本控制管理的文件创建.ignore文件，与.git/文件夹同一级，即在项目的根目录: 1234.git/ ... ....ignore 在.ignore文件中输入要过滤的文件和文件夹: 123_post/java*.md.gitignore #忽略.gitignore文件本身 git忽略已经提交过的文件有些时候会因为不小心或者疏忽而导致将本不需要加入版本控制的文件加入到了版本控制中，这时候修改.ignore文件就没有效果了 解决方案: 先删除本地缓存，然后在ignore文件中填入要忽略的文件，最后再提交 1234git rm -r --cached xxx //xxx表示不再想版本控制的文件# 然后在.gitignore 文件中加入该忽略的文件git add .git commit -m 'update .gitignore'","tags":[{"name":"git","slug":"git","permalink":"https://mraye.github.io/tags/git/"}]},{"title":"ThreadLocal关键字","date":"2018-05-26T14:09:30.000Z","path":"2018/05/26-threadlocal-cognize.html","text":"线程局部变量，只有当前线程可以访问。既然只有当前线程可以访问，自然是线程安全的 ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread(ThreadLocal实例通常是一个类中的私有的属性private static,并且期望状态和线程相关联) ThreadLocal生命周期在ThreadLocal的API中指出： Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).(只要当前线程存活并且ThreadLocal实例可以访问，每个线程都保存对其线程局部变量副本的隐式引用。线程消失后，线程本地实例的所有副本都将被垃圾收集（除非存在对这些副本的其他引用）) ThreadLocal内部实现12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 在ThreadLocal的set方法中，先获取当前线程对象，getMap方法通过当前线程获取ThreadLocalMap对象[可以当成是类似是map]，如果map不为空，则将当前threadlocal实例作为key设置到ThreadLocalMap中,不然先创建ThreadLocalMap,然后设值 12345678910111213141516171819202122232425public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 在ThreadLocal的get方法中，先获取当前线程对象，getMap方法通过当前线程获取ThreadLocalMap对象[可以当成是类似是map]，如果map不为空,则将当前threadlocal实例作为key值从map中取出value并返回。如果map没能创建，则调用setInitialValue方法，步骤与set方法差不多 那么ThreadLocalMap是什么呢？ 12345678910111213141516static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; private static final int INITIAL_CAPACITY = 16; private Entry[] table;&#125; 可以看到，ThreadLocalMap中包含一个table数组，数组中装有Entry对象，其中Entry是一个类似map的key-value存储的对象，以threadlocal实例为key。现在可以明白，一个线程中绑定了一个ThreadLocalMap，而ThreadLocalMap中包含多个以threadlocal实例为key的Entry对象 ThreadLocalMap中的set操作： 12345678910111213141516171819202122232425262728293031323334353637private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; // 找到要存储的索引位置 int i = key.threadLocalHashCode &amp; (len-1); // 如果索引位置不为空null(已经存在Entry对象) for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果 当前索引的key所代表的是同一个threadlocal实例 // 则用新值替换 if (k == key) &#123; e.value = value; return; &#125; // 如果threadlocal实例已经被回收了即 null ---&gt; value // 就用新值new Entry(key, value)替换原来的旧slot中的Entry对象 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 如果索引位置没有Entry对象，则插入新增 tab[i] = new Entry(key, value); int sz = ++size; // 清除陈旧的Entry后，并且size 超过了阀值 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) // 尝试移除陈旧的(无效)Entry,如果size 还是超过了阀值，就调整table的大小(扩容) rehash();&#125; ThreadLocalMap中的getEntr方法 12345678910111213141516171819202122232425262728private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; // 根据key计算在table中的索引位置 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; // 直接命中 if (e != null &amp;&amp; e.get() == key) return e; else // 非直接命中(hashcode冲突)，遍历整个table当且仅当 key==e.get() return getEntryAfterMiss(key, i, e);&#125;private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; ThreadLocalMap中的remove方法: 123456789101112131415// 根据key删除Entry对象private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; 回头再看Entry的定义: 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry继承了WeakReference(弱引用)，那什么是WeakReference？在系统GC的时候，只要发现是弱引用，不管堆空间是否足够，都会将对象进行回收，即当Entry中的key变成null(threadLocal实例被回收),那么GC也就会立即将这个key值为null的Entry回收，防止内存泄露，这就是key值不使用强引用的原因 可以看到在ThreadLocalMap中的 set()，get() 和 remove()中都有清除key为null值的操作，说白就是为了避免内存泄露 由于ThreadLocal生命周期的特性，如果使用不当，将会出现内存泄露的问题 内存泄露(Memory Leak) A memory leak in Java is amount of memory hold by object which are not in use and should have been garbage collected, but because of unintended strong references, they still live in Java heap space(Java中的内存泄露是指一些本该被垃圾收集器回收并且占有很大内存的对象，因为一些意外强引用strong references,致使它们仍旧存活在Java的堆空间中) ThreadLoacl发生内存泄露的场景 ThreadLocal的生命周期随着当前线程创建而创建，销毁而销毁的。特别是在使用线程池时(固定数量线程池)，线程可能会被复用，线程会一直持有ThreadLocalMap的引用，如果在ThreadLocalMap中已经存储了一个Entry(tl_instance, value)的对象，如果以key为tl_instance的Entry在使用之后中并没有被及时的移除，并且value引用是一个占用内存比较大的强引用对象，又假设可能这个tl_instance很长时间都不会被用到(名存实亡)，那么就会造成内存泄露，如果及时将不用的tl_instance设成null值，由于Entry中key是弱引用的特性，就会回收长时间不使用key值为tl_instance的Entry,并且将value的引用对象也一并回收，保证内存不泄露 安全使用ThreadLocal:每次调用threadloal变量时，把它放在try..finally代码块中，并在在finally中调用threadlocal中的remove方法，如: 12345try&#123; sdf = threadlocal.get();&#125;finally&#123; threadlocal.remove();&#125; 使用ThreadLocal都知道SimpleDateFormat在多线程环境下，在不使用任何同步机制的时候是线程不安全的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class ThreadLocalSdf &#123; private static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private static final ThreadLocal&lt;SimpleDateFormat&gt; sdfl = new ThreadLocal&lt;&gt;(); //线程不安全 public static void commonSdf() throws InterruptedException &#123; Thread[] threads = new Thread[20]; final CountDownLatch startLatch = new CountDownLatch(1); for (int i=0; i &lt; 20; i++)&#123; threads[i] = new Thread()&#123; @Override public void run() &#123; try &#123; startLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Date date = sdf.parse(\"2018-03-28 12:23:\"+(new Random().nextInt()%60)); System.out.println(sdf.format(date)); &#125; catch (ParseException e) &#123; e.printStackTrace();e.printStackTrace(); &#125; &#125; &#125;; threads[i].start(); &#125; Thread.sleep(200); startLatch.countDown(); for (Thread thread: threads)&#123; thread.join(); &#125; &#125; // 使用threadlocal构建线程安全的SimpleDateFormat public static void threadlcSdf() throws InterruptedException &#123; Thread[] threads = new Thread[20]; final CountDownLatch startLatch = new CountDownLatch(1); for (int i=0; i &lt; 20; i++)&#123; threads[i] = new Thread()&#123; @Override public void run() &#123; try &#123; startLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; if (sdfl.get() == null)&#123; sdfl.set(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); &#125; Date date = sdfl.get().parse(\"2018-03-28 12:23:\"+(new Random().nextInt()%60)); System.out.println(sdfl.get().format(date)); &#125; catch (ParseException e) &#123; e.printStackTrace();e.printStackTrace(); &#125; &#125; &#125;; threads[i].start(); &#125; Thread.sleep(200); startLatch.countDown(); for (Thread thread: threads)&#123; thread.join(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; commonSdf();// threadlcSdf(); &#125;&#125; 运行commonSdf方法,会出现以下异常: 123456java.lang.NumberFormatException: For input string: \"\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2051)","tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://mraye.github.io/tags/ThreadLocal/"}]},{"title":"CAS(Compare And Swap)导致的ABA问题","date":"2018-05-26T14:04:41.000Z","path":"2018/05/26-aba-problem.html","text":"问题描述 多线程情况下，每个线程使用CAS操作欲将数据A修改成B，当然我们只希望只有一个线程能够正确的修改数据，并且只修改一次。当并发的时候，其中一个线程已经将A成功的改成了B，但是在线程并发调度过程中尚未被调度，在这个期间，另外一个线程(不在并发中的请求线程)将B又修改成了A，那么原来并发中的线程又可以通过CAS操作将A改成B 测试用例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class AbaPro &#123; private static final Random RANDOM = new Random(); private static final String B = \"B\"; private static final String A = \"A\"; public static final AtomicReference&lt;String&gt; ATOMIC_REFERENCE = new AtomicReference&lt;&gt;(A); public static void main(String[] args) throws InterruptedException &#123; final CountDownLatch startLatch = new CountDownLatch(1); Thread[] threads = new Thread[20]; for (int i=0; i &lt; 20; i++)&#123; threads[i] = new Thread()&#123; @Override public void run() &#123; String oldValue = ATOMIC_REFERENCE.get(); try &#123; startLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(RANDOM.nextInt()&amp;500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ATOMIC_REFERENCE.compareAndSet(oldValue, B ))&#123; System.out.println(Thread.currentThread().getName()+ \" 已经对原始值进行了修改,此时值为: \"+ ATOMIC_REFERENCE.get()); &#125; &#125; &#125;; threads[i].start(); &#125; startLatch.countDown(); Thread.sleep(200); new Thread()&#123; @Override public void run() &#123; try &#123; Thread.sleep(RANDOM.nextInt() &amp; 200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String oldVal = ATOMIC_REFERENCE.get(); while (!ATOMIC_REFERENCE.compareAndSet(ATOMIC_REFERENCE.get(), A)); System.out.println(Thread.currentThread().getName() +\" 已经将值 \"+oldVal+\" 修改成原始值: A\"); &#125; &#125;.start(); &#125;&#125; 结果: 123Thread-12 已经对原始值进行了修改,此时值为: BThread-20 已经将值 B 修改成原始值: AThread-14 已经对原始值进行了修改,此时值为: B 可以看到并发中的线程Thread-12已经成功的将A修改成B，其他线程Thread-20在某一时刻将B修改成A，而并发中的线程Thread-14又能再次成功的将A修改成B，虽然最终结果是B,但是中途经历了一次被修改的过程，在某些情况下是致使的 解决方案 java中提供了AtomicStampedReference来解决这个问题，它是基于版本或者是一种状态，在修改的过程中不仅对比值，也同时会对比版本号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class AabProResolve &#123; private static final Random RANDOM = new Random(); private static final String B = \"B\"; private static final String A = \"A\"; private static final AtomicStampedReference&lt;String&gt; ATOMIC_STAMPED_REFERENCE = new AtomicStampedReference&lt;&gt;(A,0); public static void main(String[] args) throws InterruptedException &#123; final CountDownLatch startLatch = new CountDownLatch(1); Thread[] threads = new Thread[20]; for (int i=0; i &lt; 20; i++)&#123; threads[i] = new Thread()&#123; @Override public void run() &#123; String oldValue = ATOMIC_STAMPED_REFERENCE.getReference(); int stamp = ATOMIC_STAMPED_REFERENCE.getStamp(); try &#123; startLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(RANDOM.nextInt() &amp; 500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ATOMIC_STAMPED_REFERENCE.compareAndSet(oldValue, B, stamp, stamp+1))&#123; System.out.println(Thread.currentThread().getName()+ \" 已经对原始值: \"+oldValue+\" 进行了修改,此时值为: \"+ ATOMIC_STAMPED_REFERENCE.getReference()); &#125; &#125; &#125;; threads[i].start(); &#125; Thread.sleep(200); startLatch.countDown(); new Thread()&#123; @Override public void run() &#123; try &#123; Thread.sleep(RANDOM.nextInt() &amp; 200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int stamp = ATOMIC_STAMPED_REFERENCE.getStamp(); String oldVal = ATOMIC_STAMPED_REFERENCE.getReference(); while (!ATOMIC_STAMPED_REFERENCE.compareAndSet( B, A,stamp, stamp+1))&#123; stamp = ATOMIC_STAMPED_REFERENCE.getStamp(); &#125; System.out.println(Thread.currentThread().getName() +\" 已经将值 \"+oldVal+\" 修改成原始值: A\"); &#125; &#125;.start(); &#125;&#125; 结果: 12Thread-1 已经对原始值: A 进行了修改,此时值为: BThread-20 已经将值 B 修改成原始值: A 可以看到并发期间的线程只有Thread-1对A进行了修改，保证了只有一个线程对数据的修改，短暂的并发时间之后的其他线程Thread-20对其修改自然也就没有影响","tags":[{"name":"ABA","slug":"ABA","permalink":"https://mraye.github.io/tags/ABA/"}]},{"title":"java中重写equals一定要重写hashCode方法","date":"2018-05-26T14:00:08.000Z","path":"2018/05/26-java-equals-hashcode.html","text":"java中重写equals一定要重写hashCode方法原作者博客地址: Working With hashcode() and equals() equals和hashCode方法 equals(Object obj): 由Object类提供，用来判断当前对象和obj是否相等。JDK中默认实现方式是基于内存地址：只有两个对象的内存地址相等，那么它们才相等 hashCode(): 该方法由Object类提供，返回一个整型数值代表了对象在内存的地址，对于每一个对象，hashCode()方法随机返回一个唯一的整型的数值 使用规则 如果x.equals(y)==true,那么x.hashCode()==y.hashCode()也必须返回true 也就是说，如果重写了类中的equals方法，那么必须重写hashCode方法 实体类Ball.java: 1234567891011121314151617181920212223242526public class Ball &#123; private int id; private String color; public Ball(int id, String color) &#123; this.id = id; this.color = color; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125; 情景1: 直接使用Object默认实现的equals和hashCode方法测试: 12345678@Testpublic void commonEquals()&#123; Ball ball1 = new Ball(1, \"red\"); Ball ball2 = new Ball(1, \"red\"); System.out.println(\"ball1 hashcode: \"+ ball1.hashCode()); System.out.println(\"ball2 hashcode: \"+ ball2.hashCode()); System.out.println(\"ball1.equals(ball2): \"+ ball1.equals(ball2));&#125; 结果: 123ball1 hashcode: 26947503ball2 hashcode: 22527820ball1.equals(ball2): false 很明显，不同的对象，hashcode不相等，ball1和ball2自然不相等 情景2: 重写equals方法，但不重写hashCode方法重写equals方法: 123456789@Overridepublic boolean equals(Object obj)&#123; if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Ball that = (Ball)obj; return id==that.getId();&#125; 结果: 123ball1 hashcode: 30430942ball2 hashcode: 16191201ball1.equals(ball2): true 在equals方法中，我们使用id作为两个对象相等的条件 如果在ArrayList中使用只重写equals之后的Ball 12345678910@Testpublic void equalsWithArrayList()&#123; ArrayList&lt;Ball&gt; arrayList = new ArrayList&lt;&gt;(); Ball ball1 = new Ball(1, \"red\"); Ball ball2 = new Ball(1, \"red\"); arrayList.add(ball1); arrayList.add(ball2); System.out.println(\"arrayList size: \"+ arrayList.size()); System.out.println(\"arrayList contains Ball: \"+ arrayList.contains(new Ball(1,\"red\")));&#125; 好像并没有发现什么， ArrayList中本来就允许重复元素 如果在HashMap中使用只重写之后的Ball 12345678910@Testpublic void equalsWithHashMap()&#123; HashMap&lt;Ball, Integer&gt; map = new HashMap&lt;&gt;(); Ball ball1 = new Ball(1, \"red\"); Ball ball2 = new Ball(1, \"red\"); map.put(ball1, 1); map.put(ball2,1); System.out.println(\"map size: \"+ map.size()); System.out.println(\"map contains Ball: \"+ map.get(new Ball(1,\"red\")));&#125; 结果: 12map size: 2map contains Ball: null 讲道理，map的size应该是1，而且map.get(new Ball(1, &quot;red&quot;))应该返回1，什么情况？找到HashMap的put源码: 12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 好吧，HashMap的put操作时，先是比较hashCode值是否相等，然后比较equals方法，如果hashCode不相等，则认为是addEntry操作。实际上，Ball没有重写hashCode方法,第一new的操作，都会在内存中分配不同的地址，所以map.size=2。 再看，map.get()源码方法： 12345678910111213141516171819202122232425//HashMap.get()源码public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; 可以看到，取值的时候先计算对象的hashCode值，map.get(new Ball(1,&quot;red&quot;)),匿名new Ball(1,”red”),之前没有重写hashCode方法，又会产生新的hashCode，所以取出的是null 重写hashCode方法1234@Overridepublic int hashCode() &#123; return id;&#125; 再次运行equalsWithHashMap测试用例,结果: 12map size: 1map contains Ball: 1 可以看到，这次map的size为1，表明加入的ball1和ball2为同一实例 同样也适用于HashSet,HashTable,或者其他以hashCode机制作为存储的数据结构 结论:在重写了equals方法后，强制要求重写hashCode方法 如果两个对象相等，那么他们必须有相同的hashCode 如果两个对象有相同的hashCode,并不意味着他们相等 单独重写equals方法会让业务中使用哈希数据结构的数据失效，如HashMap,HashSet,HashTable…","tags":[{"name":"hashCode","slug":"hashCode","permalink":"https://mraye.github.io/tags/hashCode/"}]},{"title":"trycatchfinally的一些理解","date":"2018-05-26T13:56:23.000Z","path":"2018/05/26-try-catch-finally.html","text":"trycatchfinally的一些理解情景1:try-finally-with-return测试用例： 12345678910111213141516public int tfWithReturnTest()&#123; try&#123; System.out.println(\"enter try block...\"); return 1; &#125;finally &#123; System.out.println(\"enter finally block...\");// return 2; &#125;&#125;//junit test case@Testpublic void tcfTest()&#123; int rs = tfWithReturnTest(); System.out.println(\"result: \"+ rs);&#125; 结果: 123enter try block...enter finally block...result: 1 打开finally代码块中的return语句,再次执行testCase: 123enter try block...enter finally block...result: 2 可以发现，无论有没有return,程序都会执行finally块中的代码，如果finally中没有return,程序执行完try中代码便把控制权转交给finally,处理完finally中扩逻辑之后又把控制权转交给try中的return返回最后的结果;如果finally中存在return,程序执行完try中代码便把控制权转交给finally,处理完finally逻辑之后就直接返回结果，不再走try中的return 情景2:try-finally-exception-with-return测试用例:12345678910111213141516171819public int tfExceptionWithReturnTest()&#123; try&#123; System.out.println(\"enter try block...\"); if (1==1) &#123; throw new IllegalArgumentException(\"IllegalArgumentException in try block...\"); &#125; return 1; &#125;finally &#123; System.out.println(\"enter finally block...\"); // return 2; &#125;&#125;//junit test case@Testpublic void tcfTest()&#123; int rs = tfExceptionWithReturnTest(); System.out.println(\"result: \"+ rs);&#125; 结果: 123enter try block...enter finally block...java.lang.IllegalArgumentException: IllegalArgumentException in try block... 打开finally代码块中的return语句,再次执行结果: 123enter try block...enter finally block...result: 2 可以发现，无论有没有return,程序都会执行finally块中的代码，如果finally中没有return,程序执行完try中代码将要抛出异常时，便把控制权转交给finally,处理完finally中扩逻辑之后又把控制权转交给try，让try中执行throw exception的操作;如果finally中存在return,程序执行完try中代码将要抛出异常时，便把控制权转交给finally,处理完finally逻辑之后就直接返回结果，不再让try中执行throw exception的操作 情景3:try-catch-finally-exception-with-return1234567891011121314151617181920212223242526public int tcfWithReturnTest()&#123; try&#123; System.out.println(\"enter try block...\");// if (1==1) &#123;// throw new IllegalArgumentException(\"IllegalArgumentException in try block...\");// &#125; return 1; &#125;catch (Throwable t)&#123; System.out.println(\"enter catch block...\");// throw new RuntimeException(\"throw runtimeException in catch block...\"); return 2; &#125;finally &#123; System.out.println(\"enter finally block...\");// return 3; &#125;&#125;//junit test case@Testpublic void tcfTest()&#123;// int rs = tfWithReturnTest();// int rs = tfExceptionWithReturnTest(); int rs = tcfWithReturnTest(); System.out.println(\"result: \"+ rs);&#125; 1.正常运行结果: 123enter try block...enter finally block...result: 1 2.打开finally代码块中的return语句： 12345678910111213141516public int tcfWithReturnTest()&#123; try&#123; System.out.println(\"enter try block...\");// if (1==1) &#123;// throw new IllegalArgumentException(\"IllegalArgumentException in try block...\");// &#125; return 1; &#125;catch (Throwable t)&#123; System.out.println(\"enter catch block...\");// throw new RuntimeException(\"throw runtimeException in catch block...\"); return 2; &#125;finally &#123; System.out.println(\"enter finally block...\"); return 3; &#125; &#125; 结果:123enter try block...enter finally block...result: 3 //直接在finally块中返回，而不是将控制权交给try,让try返回结果 3.打开try中的抛出异常代码: 12345678910111213141516public int tcfWithReturnTest()&#123; try&#123; System.out.println(\"enter try block...\"); if (1==1) &#123; throw new IllegalArgumentException(\"IllegalArgumentException in try block...\"); &#125; return 1; &#125;catch (Throwable t)&#123; System.out.println(\"enter catch block...\");// throw new RuntimeException(\"throw runtimeException in catch block...\"); return 2; &#125;finally &#123; System.out.println(\"enter finally block...\");// return 3; &#125;&#125; 结果: 1234enter try block...enter catch block...enter finally block...result: 2 //返回的是catch中的值 可以看到，finally代码块无论如何都会被执行，在try中抛出异常之后，catch代码块中捕获异常，处理catch中的逻辑之后在抛出异常之前(或return之前)，将控制权交给finally块中，但finally中没有retun关键字，就又将控制权交给catch,由catch抛出异常(或直接return返回值) 综上所述: finally在try-catch-finally语句中一定会被执行 如果finally中没有return关键字，程序会在执行finally代码块中的逻辑之后将控制权交给try或者是catch代码块;如果在try中抛出异常，先执行catch中逻辑,如果catch中return或者是throw Exception操作时，先将控制权交给finally,在finally中处理逻辑之后，将控制权交给catch,由catch执行throw Exception和return的操作","tags":[{"name":"try","slug":"try","permalink":"https://mraye.github.io/tags/try/"}]},{"title":"InputStream不能重用问题","date":"2018-05-26T13:43:52.000Z","path":"2018/05/26-inputstream-no-reuse.html","text":"问题：使用InpustStream读取文件内容，并且使用同一个InputStream进行对象反序列化的时候 123456789101112131415161718192021222324@Testpublic void readFromFile()&#123; File file = new File(\"person.data\"); try (InputStream is = new FileInputStream(file)) &#123; byte[] bytes = new byte[1024]; int len = 0; StringBuilder sb = new StringBuilder(); while ((len=is.read(bytes))!=-1)&#123; sb.append(new String(bytes, \"UTF-8\")); &#125; System.out.println(sb.toString()); ObjectInputStream ois = new ObjectInputStream(is); Person person = (Person) ois.readObject(); System.out.println(person); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 结果: 123456java.io.EOFException at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2325) at java.io.ObjectInputStream$BlockDataInputStream.readShort(ObjectInputStream.java:2794) at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:801) at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:299) 原来是InputStream在进行一次读取之后不能被重复使用 解决方案 重新打开一个InputStream 将InputStream流中读取的字节写入ByteArrayOutputStream中暂存，用ByteArrayOutputStream可以重新构建多个InputStream达到重复使用的效果 使用ByteArrayOutputStream暂存方法 123456789101112131415161718192021222324@Testpublic void readFromFile()&#123; File file = new File(\"person.data\"); try (InputStream is = new FileInputStream(file)) &#123; byte[] bytes = new byte[1024]; int len = 0; ByteArrayOutputStream baos = new ByteArrayOutputStream(); while ((len=is.read(bytes))!=-1)&#123; baos.write(bytes,0, len); &#125; System.out.println(new String(baos.toByteArray(), \"UTF-8\")); InputStream reuseIs = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(reuseIs); Person person = (Person) ois.readObject(); System.out.println(person); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 结果: 12//omit file content...Person&#123;name='null', age=0&#125;","tags":[{"name":"inputstream","slug":"inputstream","permalink":"https://mraye.github.io/tags/inputstream/"}]},{"title":"spring结合mybatis时一级缓存失效问题","date":"2018-05-26T13:37:09.000Z","path":"2018/05/26-mybatis-cache-invalid.html","text":"之前了解到mybatis的一级缓存是默认开启的，作用域是sqlSession,是基 HashMap的本地缓存。不同的SqlSession之间的缓存数据区域互不影响。当进行select、update、delete操作后并且commit事物到数据库之后，sqlSession中的Cache自动被清空 1&lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; 结论spring结合mybatis后，一级缓存作用： 在未开启事物的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession,因此此时的一级缓存是没有启作用的 在开启事物的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是有效的 案例情景一:未开启事物 123456789101112131415161718@Service(\"countryService\")public class CountryService &#123; @Autowired private CountryDao countryDao; // @Transactional 未开启事物 public void noTranSactionMethod() throws JsonProcessingException &#123; CountryDo countryDo = countryDao.getById(1L); CountryDo countryDo1 = countryDao.getById(1L); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(countryDo); String json1 = objectMapper.writeValueAsString(countryDo1); System.out.println(json); System.out.println(json1); &#125;&#125; 测试案例: 1234@Testpublic void transactionTest() throws JsonProcessingException &#123; countryService.noTranSactionMethod();&#125; 结果: 123456789101112131415[DEBUG] SqlSessionUtils Creating a new SqlSession[DEBUG] SpringManagedTransaction JDBC Connection [com.mysql.jdbc.JDBC4Connection@14a54ef6] will not be managed by Spring[DEBUG] getById ==&gt; Preparing: SELECT * FROM country WHERE country_id = ?[DEBUG] getById ==&gt; Parameters: 1(Long)[DEBUG] getById &lt;== Total: 1[DEBUG] SqlSessionUtils Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3359c978][DEBUG] SqlSessionUtils Creating a new SqlSession[DEBUG] SqlSessionUtils SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2aa27288] was not registered for synchronization because synchronization is not active[DEBUG] SpringManagedTransaction JDBC Connection [com.mysql.jdbc.JDBC4Connection@14a54ef6] will not be managed by Spring[DEBUG] getById ==&gt; Preparing: SELECT * FROM country WHERE country_id = ?[DEBUG] getById ==&gt; Parameters: 1(Long)[DEBUG] getById &lt;== Total: 1[DEBUG] SqlSessionUtils Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2aa27288]&#123;\"countryId\":1,\"country\":\"Afghanistan\",\"lastUpdate\":\"2006-02-15 04:44:00.0\"&#125;&#123;\"countryId\":1,\"country\":\"Afghanistan\",\"lastUpdate\":\"2006-02-15 04:44:00.0\"&#125; 可以看到，两次查询，都创建了新的sqlSession,并向数据库查询，此时缓存并没有起效果 情景二: 开启事物 打开@Transactional注解: 1234567891011121314151617@Service(\"countryService\")public class CountryService &#123; @Autowired private CountryDao countryDao; @Transactional public void noTranSactionMethod() throws JsonProcessingException &#123; CountryDo countryDo = countryDao.getById(1L); CountryDo countryDo1 = countryDao.getById(1L); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(countryDo); String json1 = objectMapper.writeValueAsString(countryDo1); System.out.println(json); System.out.println(json1); &#125;&#125; 使用原来的测试案例，输出结果: 123456789101112[DEBUG] SqlSessionUtils Creating a new SqlSession[DEBUG] SqlSessionUtils Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@109f5dd8][DEBUG] SpringManagedTransaction JDBC Connection [com.mysql.jdbc.JDBC4Connection@55caeb35] will be managed by Spring[DEBUG] getById ==&gt; Preparing: SELECT * FROM country WHERE country_id = ?[DEBUG] getById ==&gt; Parameters: 1(Long)[DEBUG] getById &lt;== Total: 1[DEBUG] SqlSessionUtils Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@109f5dd8]// 从当前事物中获取sqlSession[DEBUG] SqlSessionUtils Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@109f5dd8] from current transaction[DEBUG] SqlSessionUtils Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@109f5dd8]&#123;\"countryId\":1,\"country\":\"Afghanistan\",\"lastUpdate\":\"2006-02-15 04:44:00.0\"&#125;&#123;\"countryId\":1,\"country\":\"Afghanistan\",\"lastUpdate\":\"2006-02-15 04:44:00.0\"&#125; 可以看到，两次查询，只创建了一次sqlSession,说明一级缓存起作用了 跟踪源码从SqlSessionDaoSupport作为路口，这个类在mybatis-spring包下，sping为sqlSession做了代理 12345678910111213public abstract class SqlSessionDaoSupport extends DaoSupport &#123; private SqlSession sqlSession; private boolean externalSqlSession; public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; if (!this.externalSqlSession) &#123; this.sqlSession = new SqlSessionTemplate(sqlSessionFactory); &#125; &#125; //....omit&#125; 创建了SqlSessionTemplate后,在SqlSessionTemplate中: 123456789101112131415public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\"); notNull(executorType, \"Property 'executorType' is required\"); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; //代理了SqlSession this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());&#125; 再看SqlSessionInterceptor,SqlSessionInterceptor是SqlSessionTemplate的内部类: 1234567891011121314151617181920212223242526272829303132333435363738394041public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; // ...omit.. private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; Object result = method.invoke(sqlSession, args); //如果尚未开启事物(事物不是由spring来管理)，则sqlSession直接提交 if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() // 手动commit sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; //一般情况下，默认都是关闭sqlSession if (sqlSession != null) &#123; closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125;&#125; 再看getSqlSession方法，这个方法是在SqlSessionUtils.java中的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); //获取holder SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); //从sessionHolder中获取SqlSession SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"Creating a new SqlSession\"); &#125; //如果sqlSession不存在，则创建一个新的 session = sessionFactory.openSession(executorType); //将sqlSession注册在sessionHolder中 registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session;&#125;private static void registerSessionHolder(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator, SqlSession session) &#123; SqlSessionHolder holder; //在开启事物的情况下 if (TransactionSynchronizationManager.isSynchronizationActive()) &#123; Environment environment = sessionFactory.getConfiguration().getEnvironment(); //由spring来管理事物的情况下 if (environment.getTransactionFactory() instanceof SpringManagedTransactionFactory) &#123; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"Registering transaction synchronization for SqlSession [\" + session + \"]\"); &#125; holder = new SqlSessionHolder(session, executorType, exceptionTranslator); //将sessionFactory绑定在sessionHolde相互绑定 TransactionSynchronizationManager.bindResource(sessionFactory, holder); TransactionSynchronizationManager.registerSynchronization(new SqlSessionSynchronization(holder, sessionFactory)); holder.setSynchronizedWithTransaction(true); holder.requested(); &#125; else &#123; if (TransactionSynchronizationManager.getResource(environment.getDataSource()) == null) &#123; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"SqlSession [\" + session + \"] was not registered for synchronization because DataSource is not transactional\"); &#125; &#125; else &#123; throw new TransientDataAccessResourceException( \"SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization\"); &#125; &#125; &#125; else &#123; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"SqlSession [\" + session + \"] was not registered for synchronization because synchronization is not active\"); &#125; &#125; 再看TransactionSynchronizationManager.bindResource的方法: 123456789101112131415161718192021222324252627282930313233public abstract class TransactionSynchronizationManager &#123; //omit... private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(\"Transactional resources\"); // key:sessionFactory, value:SqlSessionHolder(Connection) public static void bindResource(Object key, Object value) throws IllegalStateException &#123; Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key); Assert.notNull(value, \"Value must not be null\"); //从threadLocal类型的resources中获取与当前线程绑定的资源，如sessionFactory，Connection等等 Map&lt;Object, Object&gt; map = resources.get(); // set ThreadLocal Map if none found if (map == null) &#123; map = new HashMap&lt;Object, Object&gt;(); resources.set(map); &#125; Object oldValue = map.put(actualKey, value); // Transparently suppress a ResourceHolder that was marked as void... if (oldValue instanceof ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123; oldValue = null; &#125; if (oldValue != null) &#123; throw new IllegalStateException(\"Already value [\" + oldValue + \"] for key [\" + actualKey + \"] bound to thread [\" + Thread.currentThread().getName() + \"]\"); &#125; if (logger.isTraceEnabled()) &#123; logger.trace(\"Bound value [\" + value + \"] for key [\" + actualKey + \"] to thread [\" + Thread.currentThread().getName() + \"]\"); &#125; &#125;&#125; 这里可以看到，spring是如何做到获取到的是同一个SqlSession,前面的长篇大论，就是为使用ThreadLocal将当前线程绑定创建SqlSession相关的资源，从而获取同一个sqlSession","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://mraye.github.io/tags/mybatis/"},{"name":"cache","slug":"cache","permalink":"https://mraye.github.io/tags/cache/"}]},{"title":"mybatis中使用pageHelper实现一对多分页","date":"2018-05-26T13:32:07.000Z","path":"2018/05/26-pagehelper-onetomany.html","text":"mybatis中使用pageHelper实现一对多分页项目里经常遇到一对多分页的问题，以前认为PageHelper不支持一对多的分页，还一直自己重写分页方法。。。。 数据库表 country表 123456CREATE TABLE `country` ( `country_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `country` varchar(50) NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`country_id`)) ENGINE=InnoDB AUTO_INCREMENT=110 DEFAULT CHARSET=utf8; city表 12345678910CREATE TABLE `city` ( `city_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `city` varchar(50) NOT NULL, `country_id` smallint(5) unsigned NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`city_id`), KEY `idx_fk_country_id` (`country_id`), CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE) ENGINE=InnoDB AUTO_INCREMENT=601 DEFAULT CHARSET=utf8; pageHelper配置使用gradle依赖: 123456dependencies &#123; /* omit... */ testCompile group: 'junit', name: 'junit', version: '4.12' compile 'com.github.pagehelper:pagehelper:5.1.4'&#125; 在spring-context.xml配置pageHelper插件： 1234567891011121314151617181920&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.github.**.domain\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mappings/**/*.xml\"/&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 --&gt; &lt;property name=\"properties\"&gt; &lt;value&gt; helperDialect=mysql reasonable=true autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; countryDo和cityDo: 1234567891011121314151617public class CityDo implements Serializable &#123; private static final long serialVersionUID = -1453407185811057526L; private Long cityId; private Long countryId; private String city; private String lastUpdate; // ...omit getter and setter&#125;public class CountryDo implements Serializable &#123; private static final long serialVersionUID = 7914312649965400868L; private Long countryId; private String country; private String lastUpdate; // ...omit getter and setter&#125; countryManager.java文件: 12345678910111213141516171819@Component(\"countryManager\")public class CountryManager &#123; @Autowired private CountryDao countryDao; public List&lt;Map&lt;String, Object&gt;&gt; findCountryList(Map&lt;String, Object&gt; map)&#123; PageInfo&lt;Map&lt;String, Object&gt;&gt; page = null; PageHelper.startPage( map.get(\"pageIndex\")==null ? 1 : Integer.valueOf(map.get(\"pageIndex\").toString()), map.get(\"pageSize\")==null ? 2 : Integer.valueOf(map.get(\"pageSize\").toString()) ); List&lt;Map&lt;String, Object&gt;&gt; list = countryDao.findCountryList(map); page = new PageInfo&lt;&gt;(list); return page.getList(); &#125;&#125; mapper映射文件CountryDao.xml,所有一对多关系都是懒加载的: 12345678910111213141516171819202122232425262728293031&lt;resultMap id=\"findCountryListMap\" type=\"map\"&gt; &lt;result property=\"countryId\" column=\"countryId\"/&gt; &lt;result property=\"country\" column=\"country\"/&gt; &lt;collection property=\"cityList\" column=\"countryId\" ofType=\"map\" javaType=\"java.util.List\" select=\"getCityByCountryId\"&gt; &lt;result property=\"city\" column=\"city\"/&gt; &lt;result property=\"cityId\" column=\"cityId\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"getCityByCountryId\" parameterType=\"long\" resultType=\"map\"&gt; SELECT ci.city, ci.city_id cityId FROM city ci WHERE //countryId这里传值进来的是 findCountryList中countryId的列名， //即findCountryListMap中的column属性而不是property属性名 ci.country_id=#&#123;countryId&#125; order by ci.city_id&lt;/select&gt;&lt;select id=\"findCountryList\" resultMap=\"findCountryListMap\"&gt; SELECT cy.country_id countryId, cy.country FROM country cy ORDER BY cy.country_id&lt;/select&gt; 测试案例: 1234567891011121314151617@Testpublic void findCountryListTest() throws JsonProcessingException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pageIndex\",1); map.put(\"pageSize\",2); List&lt;Map&lt;String, Object&gt;&gt; result = countryManager.findCountryList(map); ObjectMapper mapper = new ObjectMapper(); ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter(); System.out.println(\"start page(1,2)\"); System.out.println(writer.writeValueAsString(result)); System.out.println(\"============================\"); System.out.println(\"start page(2,2)\"); map.put(\"pageIndex\",2); result = countryManager.findCountryList(map); System.out.println(writer.writeValueAsString(result));&#125; 测试结果: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556start page(1,2): 第一页-------------------------------------------[ &#123; \"countryId\": 1 \"country\": \"Afghanistan\", \"cityList\": [&#123; \"city\": \"Kabul\", \"cityId\": 251 &#125; ], &#125;, &#123; \"countryId\": 2 \"country\": \"Algeria\", \"cityList\": [&#123; \"city\": \"Batna\", \"cityId\": 59 &#125;, &#123; \"city\": \"Bchar\", \"cityId\": 63 &#125;, &#123; \"city\": \"Skikda\", \"cityId\": 483 &#125; ], &#125;]-------------------------------------------start page(2,2): 第2页-------------------------------------------[ &#123; \"countryId\": 3 \"country\": \"American Samoa\", \"cityList\": [&#123; \"city\": \"Tafuna\", \"cityId\": 516 &#125; ], &#125;, &#123; \"countryId\": 4 \"country\": \"Angola\", \"cityList\": [&#123; \"city\": \"Benguela\", \"cityId\": 67 &#125;, &#123; \"city\": \"Namibe\", \"cityId\": 360 &#125; ], &#125;]-------------------------------------------","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://mraye.github.io/tags/mybatis/"},{"name":"pageHelper","slug":"pageHelper","permalink":"https://mraye.github.io/tags/pageHelper/"}]},{"title":"mysql行列转换(一)","date":"2018-05-26T13:25:45.000Z","path":"2018/05/26-row-col-transfer-fst.html","text":"情景一123456789101112131415 +----+--------+---------+ | id | month | pay_fee | +----+--------+---------+ | 1 | 201801 | 10 | | 2 | 201802 | 11 | | 3 | 201803 | 54 | | 4 | 201804 | 32 | +----+--------+---------+ | V+--------+--------+--------+--------+| 201801 | 201802 | 201803 | 201804 |+--------+--------+--------+--------+| 10 | 11 | 54 | 32 |+--------+--------+--------+--------+ sql实现: 1234567891011121314151617SELECT max(CASE WHEN month='201801' THEN pay_fee ELSE 0 end) '201801', max(CASE WHEN month='201802' THEN pay_fee ELSE 0 end) '201802', max(CASE WHEN month='201803' THEN pay_fee ELSE 0 end) '201803', max(CASE WHEN month='201804' THEN pay_fee ELSE 0 end) '201804'FROM t_month或SELECT sum(CASE WHEN month='201801' THEN pay_fee ELSE 0 end) '201801', sum(CASE WHEN month='201802' THEN pay_fee ELSE 0 end) '201802', sum(CASE WHEN month='201803' THEN pay_fee ELSE 0 end) '201803', sum(CASE WHEN month='201804' THEN pay_fee ELSE 0 end) '201804'FROM t_month 情景二1234567891011121314151617mysql&gt; select * from t_month;+----+--------+---------+-----------+ | id | month | pay_fee | total_fee |+----+--------+---------+-----------+| 1 | 201801 | 10 | 20 || 2 | 201802 | 11 | 23 || 3 | 201803 | 54 | 2334 || 4 | 201804 | 32 | 6 |+----+--------+---------+-----------+ | V+--------+--------+--------+--------+| 201801 | 201802 | 201803 | 201804 |+--------+--------+--------+--------+| 10 | 11 | 54 | 32 | //pay_ee| 20 | 23 | 2334 | 6 | //total_fee+--------+--------+--------+--------+ sql实现: 12345678910111213141516171819( SELECT max(CASE WHEN month='201801' THEN pay_fee ELSE 0 end) '201801', max(CASE WHEN month='201802' THEN pay_fee ELSE 0 end) '201802', max(CASE WHEN month='201803' THEN pay_fee ELSE 0 end) '201803', max(CASE WHEN month='201804' THEN pay_fee ELSE 0 end) '201804' FROM t_month)UNION( SELECT max(CASE WHEN month='201801' THEN total_fee ELSE 0 end) '201801', max(CASE WHEN month='201802' THEN total_fee ELSE 0 end) '201802', max(CASE WHEN month='201803' THEN total_fee ELSE 0 end) '201803', max(CASE WHEN month='201804' THEN total_fee ELSE 0 end) '201804' FROM t_month) script12345678910111213141516CREATE TABLE `t_month` ( `id` int(11) NOT NULL AUTO_INCREMENT, `month` varchar(255) DEFAULT NULL, `pay_fee` int(11) DEFAULT NULL, `total_fee` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;//插入INSERT INTO t_month (`id`, `month`, `pay_fee`, `total_fee`) VALUES('1', '201801', '10', '20'),('2', '201802', '11', '23'),('3', '201803', '54', '2334'),('4', '201804', '32', '6');","tags":[{"name":"sql","slug":"sql","permalink":"https://mraye.github.io/tags/sql/"}]},{"title":"git配置多个账户","date":"2018-05-26T08:49:46.000Z","path":"2018/05/26-git配置多个账户.html","text":"创建帐户打开git-bash,查看原有帐户: 123456$ git config --list# omit...filter.lfs.process=git-lfs filter-processcredential.helper=manageruser.name=a***wuser.email=a***w@email.com 进入~/.ssh目录,可以看到原有的帐户默认使用id_rsa: 12$ lsid_rsa id_rsa.pub known_hosts 创建新用户，并创建ssh-key,且将新产生的key值重命名为id_rsa_aye,不然会覆盖原帐户的ssh-key: 12345678910$ ssh-keygen -t rsa -C \"mraye@email.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dxjm/.ssh/id_rsa): /c/Users/dxjm/.ssh/id_rsa_ayeEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/dxjm/.ssh/id_rsa_aye.Your public key has been saved in /c/Users/dxjm/.ssh/id_rsa_aye.pub.$ lsid_rsa id_rsa.pub id_rsa_aye id_rsa_aye.pub known_hosts 可以看到，已经为新帐户mraye分别创建了公钥id_rsa_aye.pub和私钥id_rsa_aye 将新产生的ssh-key交由ssh-agent管理 ssh-agent是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程.ssh-agent是管理多个ssh key的代理，受管理的私钥通过ssh-add来添加 因为这里会有多个ssh-key,因此把它交给ssh-agent来管理 进入bash: 12345$ eval `ssh-agent -s`Agent pid 12764$ ssh-add ~/.ssh/id_rsa_ayeIdentity added: /c/Users/dxjm/.ssh/id_rsa_aye (/c/Users/dxjm/.ssh/id_rsa_aye) 配置ssh-key与git服务器映射关系在~/.ssh文件夹下创建config文件: 123456789101112# 该文件用于配置私钥对应的服务器# one account Host github.com HostName github.com User git IdentityFile C:/Users/dxjm/.ssh/id_rsa # another account Host blog # github.com的别名 HostName github.com User git IdentityFile C:/Users/dxjm/.ssh/id_rsa_aye 将id_rsa_aye.pub文件内容填加到github帐户中的SSh管理中，那么对于mraye帐户来讲，以后项目的更新和提交都需要使用别名访问了。即，以前访问项目*git@github.com:mraye/mraye.github.io.git ,现在就必须访问git@blog:mraye/mraye.github.io.git*了 测试连通性12345$ ssh -T git@github.comHi e***m! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@blogHi mraye! You've successfully authenticated, but GitHub does not provide shell access.","tags":[{"name":"git","slug":"git","permalink":"https://mraye.github.io/tags/git/"}]},{"title":"书单","date":"2017-01-01T08:34:03.000Z","path":"2017/01/01-书单.html","text":"面朝大海,春暖花开 生活 书名 作者 开始日期 结束日期 人性的弱点 [美]戴尔·卡耐基 2017-01-01 ~ Effective Java中文版 [美]Joshua Bloch 2018-06-03 ~ Java并发编程的艺术 方腾飞 2018-06-03 ~ Spring源码深度解析 郝佳 2018-06-03 ~ 围城 钱钟书 2018-03-29 ~ 文章历史：2017-01-01 创建","tags":[{"name":"ebook","slug":"ebook","permalink":"https://mraye.github.io/tags/ebook/"}]},{"title":"初识hexo及搭建Yilia主题博客","date":"2016-12-31T03:51:18.000Z","path":"2016/12/31-hexo-yilia.html","text":"hexo基本命令 简称 全名 含义 hexo n “blog” hexo new “blog” 新建文章 hexo p hexo public ~~ hexo g hexo generate 生成 hexo s hexo server 启动服务预览 hexo d hexo deploy 部署 hexo s -g hexo server –generate 发布 hexo d -g hexo deploy –generate 部署 Yilia主题搭建博客博客目录： 获取Yilia主题1git clone https://github.com/litten/hexo-theme-yilia.git yilia 根目录下_config.yml配置进入目录blog\\下中的_config.yml文件配置如下： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: mraye # 博客标题 subtitle: 面朝大海 春暖花开 #博客副标题 description: 面朝大海 春暖花开 #博客副标题 author: mraye language: zh-CN #语言 timezone: Asia/Shanghai #时区 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: &apos;https://mraye.github.io/&apos; #用于绑定域名, 其他的不需要配置 root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source #源文件 public_dir: public #生成的网页文件 tag_dir: tags #标签 archive_dir: archives #归档 category_dir: categories #分类 code_dir: downloads/code i18n_dir: :lang #国际化 skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: true relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Archives #Archives 默认值为2,修改为1,Archives页面就只会列出标题,而非全文 ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable ## Archives # 2: 开启分页 # 1: 禁用分页 # 0: 全部禁用 archive: 1 category: 1 tag: 1 ## server_ip: 0.0.0.0 logger: false logger_format: jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 5 #每页文章数, 设置成 0 禁用分页 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yilia # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #部署类型, 本文使用Github repository: git@github.com:mraye/mraye.github.io.git #部署的仓库的SSH branch: master # plugins: # - hexo-generator-feed #此插件用于RSS订阅 主题Yilia中_config.yml配置进入目录blog\\themes\\yilia\\下中的_config.yml文件yilia主题中的_config.yml配置: # Header menu: 主页: / 归档: /archives # 关于我: /about # 标签: /categories # 归档: /categories/hexo # 所有文章: /archives # 随笔: /tags/随笔/ # SubNav subnav: github: &quot;https://github.com/mraye&quot; # weibo: &quot;#&quot; # rss: &quot;#&quot; #douban: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; rss: /atom.xml # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 root: # Content # 文章太长，截断按钮文字 excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为false show_all_link: &apos;阅读全文&apos; fancybox: true # 数学公式 mathjax: false # 是否在新窗口打开链接 open_in_new: false # 打赏 # 请在需要打赏的文章的md文件头部，设置属性reward: true # 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 0 # 打赏wording reward_wording: &apos;谢谢你请我吃糖果&apos; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: # 微信二维码图片地址 weixin: # Miscellaneous google_analytics: &apos;&apos; favicon: /favicon.png #你的头像url avatar: /img/avatar.jpg # 自定义图片放在 /themes/yilia/source/img/下即可 #是否开启分享 share_jia: false #是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key #若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论 duoshuo: mraye #就是在设置多说域名.duo.com之前，例如域名为xxx.duoshuo.com,那么这里就写xxx #是否开启云标签 tagcloud: true # 按年份归档,被坑了好久 nav: name: By Year url: /archives # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: false smart_menu: innerArchive: &apos;所有文章&apos; aboutme: &apos;关于我&apos; #开启—— aboutme: 面朝大海，春暖花开 主题完善修改头像将头像图片放在/themes/yilia/source/img/avatar.jpg中，然后在yilia的配置文件_confing.yml中配置: # Miscellaneous # google_analytics: &apos;&apos; favicon: /favicon.png 修改背景颜色个人喜欢暗黑色，所以就将背景颜色稍稍修改了一下,找到/themes/yilia/source/main.css下的#container.show .anm-canvas属性，修改为如下就可以: 12345#container.show .anm-canvas &#123; display: block; position: fixed; background-color: #272822 # &lt;&lt;&lt;&#125; 自动生成目录在/themes/yilia/layout/_partial/article.ejs中找到&lt;%- post.content %&gt;位置,在&lt;%- post.content %&gt;的前面加入一下代码:123456789else &#123; %&gt; &lt;% if(!index &amp;&amp; post.toc &amp;&amp; post.toc !== false)&#123; %&gt; &lt;div id=\"toc\" class=\"toc-article\"&gt; &lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;%&#125;%&gt; &lt;%- post.content %&gt;&lt;% &#125; %&gt; 在每次写文章的时候只需要将toc设置为true即可,如下:1234title: 初识hexo及搭建Yilia主题博客date: 2016-12-31 11:51:18tags: [hexo, yilia]toc: true hexo写作技巧 若希望页面显示时内容在一定程度就不显示,使用more标签: 1&lt;!-- more --&gt; 问题 deploy失败 确保安装: 1npm install hexo-deployer-git --save Yilia主题归档不分页问题 12345678# $ npm install hexo-generator-index --save# $ npm install hexo-generator-archive --save # 解决归档不分页问题# $ npm install hexo-generator-tag --savearchive_generator: per_page: 10 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: false #为了加快生成速度，按月归档就不要了 文章历史：2016-12-31 创建","tags":[{"name":"hexo","slug":"hexo","permalink":"https://mraye.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://mraye.github.io/tags/yilia/"}]}]